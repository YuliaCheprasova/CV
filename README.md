# CV
Этот репозиторий создан как дополнение к моему резюме. В нем находится проект, разработанный мною в рамках выпускной квалификационной работы. Тема работы: "Генетическое программирование для настройки скорости обучения нейронных сетей". Представленный программный код с помощью генетического программирования генерирует планировщики скорости обучения для сверточных нейронных сетей.
# Проблематика
Бакалаврская работа посвящена проблеме настройки скорости обучения нейронных сетей. Существующие методы (помимо использования постоянного значения learning rate) - Learning rate schedulers (планировщики скорости обучения), динамически изменяют этот параметр в процессе тренировки модели. Однако их использование не всегда приводит к улучшению результата обучения сети по сравнению с результатом обучения с константным значением learning rate. В связи с этим была предпринята попытка сгенерировать собственный планировщик с помощью генетического программирования. Для этого был разработан алгоритм и затем была проведена оценка его применимости путем сравнения полученных планировщиков с существующими подходами.
# Реализация
Алгоритм генетического программирования (операторы селекции, скрещивания, мутации) реализован на языке C++ (файл main.cpp). Каждый индивид представлен в виде бинарного дерева, в узлах которого находятся математические операторы (например, +, -, /, sin), а в листьях – переменные и константы. Таким образом, планировщик представляет из себя математическое выражение, по которому вычисляется скорость обучения нейронной сети. В качестве переменной выступает номер эпохи обучения, за счет этого скорость динамически изменяется в процессе тренировки модели. 
<p align="left"><img width="130" height="200" alt="image" src="https://github.com/user-attachments/assets/d928d189-5f82-4777-831f-99ed748b9a7f" /></p>
<p>Оценка сгенерированных планировщиков производится путем обучения нейронной сети с этим планировщиком. Значение функции потерь на тестовой выборке ложится в основу значения пригодности оцениваемого индивида, таким образом, чем ниже значение функции потерь, получаемое при обучении нейронной сети с использованием сгенерированного планировщика, тем лучше этот планировщик. Алгоритм для оценки индивидов написан на языке программирования Python с использованием фреймворка Pytorch (файл 1.py).</p>
Чтобы связать два алгоритма - алгоритм генетического программирования (ГП) и алгоритм, в котором реализована нейронная сеть для оценки индивидов (НС), использован файловый обмен. Алгоритм ГП передает в файл learning_rates.txt (в коде Lrs.txt) уже вычисленные значения learning rate для каждого планировщика и для каждой эпохи обучения. Алгоритм НС считывает этот файл, подставляет полученные значения при обучении нейронной сети, и записывает в файл Losses.txt значения функции потерь на тестовой выборке для каждого планировщика. Файл losses.txt (в коде Losses.txt) считывает алгоритм ГП и использует его для вычисления пригодности индивидов, формирования нового поколения и т.д. Этот цикл повторяется до тех пор, пока не будет достигнуто заданное количество поколений. Файл status.txt используется для оповещения о готовности данных от одного алгоритма другому.
<p align="left"><img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/a6792fee-8de8-4a51-9d2d-9c838af0ffbf" /></p>
Так как обучение нейронной сети занимает немалое количество времени, процесс оценки индивидов был распараллелен на три вычислительных ресурса: использовались три графических процессора NVidia GeForce RTX 3080Ti 12Gb, AMD Radeon RX 7900XT 20Gb и NVidia GeForce RTX 3060 12Gb. Поэтому алгоритм НС представлен в трех экземплярах, для каждого из которых используются свои файлы «Lrs.txt» и «Losses.txt».</p>
<p>В процессе генерации планировщиков скорости для их оценки использовалась сверточная нейронная сеть архитектуры MobileNetV2 и изображения с датасета CIFAR10. Полученные наиболее пригодные планировщики затем применялись также для обучения нейронной сети архитектуры ResNet18, что позволило проверить гипотезу о возможности использования сгенерированных планировщиков для других подобных задач и сделать положительный вывод.
